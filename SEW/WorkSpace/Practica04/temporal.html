<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<meta charset="UTF-8" />
<title>Complejidad temporal</title>
<link rel="stylesheet" type="text/css"href="estilo.css" media="screen"/>
<link rel="stylesheet" type="text/css"href="numeracion.css" media="screen"/>
</head>
<body>
  <header>
    <h1>
      <a href="#i" title="Página inicial del blog" tabindex="1"><img
      src="algoritmia.jpg" alt="logo"/>Algoritmia y otras lides</a>
    </h1>
    <h2>Análisis de algoritmos</h2>
    <ul id="ayuda">
      <li><a href="#">Acerca de</a></li>
      <li><a href="#">Navegación</a></li>
      <li><a href="#">RSS</a></li>
      <li>
        <form method="post" action="#">
		  <fieldset>
			<input type="search" size="20" placeholder="Búsqueda"/>
			<input type="submit" value="Buscar"/>
		  </fieldset>
        </form>
      </li>
    </ul>
  </header>
  <nav>
    <ul>
      <li><a href="index.html" accesskey="1">Análisis de
      algoritmos</a></li>
      <li><a href="#" accesskey="2">Complejidad
      temporal</a></li>
      <li><a href="notacion.html" accesskey="3">Notación
      asintótica</a></li>
      <li><a href="espacial.html" accesskey="4">Complejidad
      espacial</a></li>
      <li><a href="#" accesskey="5">Índice de artículos</a></li>
    </ul>
  </nav>
  <section id="main">
    <h2>Complejidad temporal</h2>
    <p>Una alternativa para calcular el tiempo de ejecución de un
      algoritmo en función del tamaño <var>n</var> del problema, es
      contar el número de instrucciones a ejecutar y multiplicarlo por
      el tiempo requerido para cada instrucción. Considérese, por
      ejemplo, el siguiente algoritmo:</p>
    <figure id="Figura1">
      <pre><code>i &#8592; 0;
k &#8592; 1;
<span class="keyword">mientras</span> i &lt; n <span class="keyword">hacer</span>
  i &#8592; i + 1;
  k &#8592; k * i;
<span class="keyword">fin mientras</span></code></pre>
      <figcaption title="Figura 1">Algoritmo de cálculo de n!</figcaption>
    </figure>
    <p>
      Los valores que tomaría la variable <var>i</var> durante la
      ejecución serían: 0, 1, 2, …, <var>n</var>. Las sentencias del
      bucle se ejecutarían <var>n</var> veces y, así, tendríamos la           
      <a href="#Tabla1">Tabla 1</a> que indica el número de veces que
      se ejecuta cada instrucción.
    </p>
    <figure id="Tabla1">
      <table>
        <thead>
          <tr>
            <th>Asignaciones</th>
            <th>Sumas</th>
            <th>Productos</th>
            <th>Comparaciones</th>
          </tr>
        </thead>
        <tbody>
          <tr class="center">
            <td class="ecuacion">2n + 2</td>
            <td class="ecuacion">n</td>
            <td class="ecuacion">n</td>
            <td class="ecuacion">n + 1</td>
          </tr>
        </tbody>
      </table>
      <figcaption class="center" title="Tabla 1">Conteo del número de
        instrucciones en la ejecución del algoritmo n!</figcaption>
    </figure>
    <p>Si, además, queremos independizar el cálculo del tiempo de
      ejecución de un algoritmo de factores externos (lenguaje de
      programación, máquina de ejecución, etc.), no debe importarnos el
      coste concreto de cada operación elemental. Bastará con saber
      cuántas operaciones elementales ejecuta un programa y cómo depende
      ese número de la talla del problema a resolver. Siendo una
      <dfn id="paso">operación elemental (o paso)</dfn> un segmento de
      código cuyo tiempo de proceso no depende de la talla del problema
      considerado y está acotado por alguna constante.</p>
    <p class="en_linea">Entre las operaciones que se consideran <a
      href="#paso">pasos</a> están las siguientes:</p>
      <ul id="tipoPaso">
        <li>operaciones aritméticas</li>
        <li>operaciones lógicas</li>
        <li>asignaciones</li>
        <li>acceso o asignación a elementos de un
        <i lang="en">array</i></li>
        <li>operaciones de entrada/salida de valores de tipos de datos
        simples (entero, real, carácter o lógico).</li>
      </ul>
    <p>
      El coste de las operaciones elementales que no son pasos se
      expresan en función del número de pasos con el que podrían
      efectuarse y el <dfn id="temporal">coste computacional temporal</dfn>
      de un algoritmo se define como el número de pasos expresado en
      función de la talla del problema. Por ejemplo, el coste
      computacional temporal del algoritmo de la <a href="#Figura1"
      >Figura 1</a> es <span class="ecuacion">t(n)=5n+3</span> (que es
      la suma de los conteos  correspondientes de la <a href="#Tabla1"
      >Tabla 1</a>). No obstante,  los factores de cada término en la
      expresión previa no son  relevantes, sustituyéndose por constantes
      arbitrarias <span class="ecuacion"
      >t(n)=c<sub>1</sub>n+c<sub>2</sub></span> .
    </p>
    <p>Cualquier secuencia de pasos cuya longitud no depende de la
      talla del problema cuenta como una cantidad constante de pasos.</p>
    <h3>Mejor caso, peor caso y caso promedio</h3>
    <p>En la práctica, la mayor parte de los algoritmos incluyen alguna
      sentencia condicional y, en consecuencia, el <a href="#temporal"
      >coste computacional temporal</a> además de depender de la talla
      del problema también va a depender de los datos concretos que se
      le presenten (casos). Esto hace que más que calcular un valor
      <span class="ecuacion">t(n)</span> del coste computacional temporal
      haya que calcular un rango de valores para el mismo</p>
    <figure class="ecuacion center">
      <p>t<sub>min</sub>(n) &#8804; t(n) &#8804; t<sub>max</sub>(n)</p>
    </figure>
    <p>los valores extremos de este rango se conocen habitualmente
      como mejor caso y peor caso. Y, entre ambos, se hallará algún
      caso promedio o más frecuente.</p>
    <p>
      Considérese, por ejemplo, el cuerpo de la función de la <a
      href="#Figura2">Figura 2</a> que busca un valor <var>x</var> en
      un <i lang="en">array</i> <var>a[0..n‑1]</var> de <var>n</var>
      elementos.
    </p>
    <figure id="Figura2">
      <pre><code>i &#8592; 0;
<span class="keyword">mientras</span> i &lt; n <span class="keyword">hacer</span>
  <span class="keyword">si</span> a[i] = x
  <span class="keyword">entonces retorna</span> cierto;
  i &#8592; i + 1;
<span class="keyword">fin mientras</span>;
<span class="keyword">retorna</span> falso;</code></pre>
      <figcaption title="Figura 2">
        Búsqueda del valor <var>x</var> en el <i lang="en">array</i>
        <var>a</var>
      </figcaption>
    </figure>
    <p>
      Dando por hecho que la construcción <code>retorna</code> fuerza la
      terminación de la función y produce un resultado (en nuestro caso,
      <code>cierto</code> o <code>falso</code>), para este algoritmo no
      resulta tan obvio determinar los valores que va a tomar la variable
      <var>i</var> durante la ejecución y el número de veces que se
      ejecuta el bucle <code>mientras</code>. La razón es que éstos van
      a depender de los datos de entrada (casos), concretamente de si el
      <i lang="en">array</i> contiene o no el valor <var>x</var> buscado
      y, en el caso de que así se sea, la posición del <i lang="en">array</i>
      en que este valor se encuentre.
    </p>
    <p>
      Cuando se habla del mejor de los casos nos referimos a los datos
      de entrada que, para cada valor particular de la talla <var>n</var>
      del problema, se resuelven más rápidamente con el algoritmo. Para
      el ejemplo de la <a href="#Figura2">Figura 2</a>, cuando el
      elemento <var>x</var> buscado se encuentra en la primera posición
      del <i lang="en">array</i>. En este caso, el bucle se ejecuta una
      única vez (y no completamente) y el algoritmo termina con una
      secuencia constante de pasos que no depende de la talla del
      problema; es decir
    </p>
    <p class="ecuacion center">
      t<sub>min</sub>(n)=c<sub>1</sub>
    </p>
    <p>
      El peor de los casos lo determinan los datos de entrada que, para
      cada valor particular de <var>n</var>, hacen que el algoritmo se
      ejecute con el mayor número posible de pasos. Para el ejemplo, el
      peor caso es cuando el algoritmo termina retornando falso; es
      decir, cuando el valor <var>x</var> buscado no se encuentra en el
      array. Siendo este el caso, el bucle se ejecuta <var>n</var> veces
      una cantidad constante de pasos; es decir
    </p>
    <p class="ecuacion center">
      t<sub>max</sub>(n)=c<sub>2</sub>n+c<sub>3</sub>
    </p>
    <p>El cálculo analítico del coste computacional temporal para el
      caso promedio (o más frecuente) es algo más complejo y sobrepasa
      los objetivos que se pretenden alcanzar aquí y, además, para
      comparar el coste temporal de los algoritmos, por lo general, será
      suficiente con comparar el peor de los casos.</p>
  </section>
  <aside>
    <h2>Sitios de interés</h2>
    <div>
      <figure>
        <figcaption>Técnicas de diseño de algoritmos</figcaption>
        <p><a href="http://www.lcc.uma.es/~av/Libro/"><img src="tda.jpg"
        alt="Libro de algoritmia"/></a></p>
      </figure>
      <figure>
        <figcaption>Portal de algoritmia</figcaption>
        <p><a href="http://www.algoritmia.net/"><img src="anet.gif"
		alt="Portal de algoritmia"/></a></p>
      </figure>
      <figure>
        <figcaption>Algoritmia</figcaption>
        <p><a href="http://es.wikibooks.org/wiki/Algoritmia"><img
        src="Wbooks.png" alt="Libro de algoritmia"/></a></p>
      </figure>
    </div>
  </aside>
  <footer>
    <address>
      <p>
        <a href="mailto:phernandez@uniovi.es"
          title="Escrito por Pedro Hernández">Pedro Hernández Arauzo</a>
        <br />Última actualización
        <time datetime="2014-09-28">28 de Septiembre de 2014</time>
      </p>
    </address>
    <p>
      Página del artículo: <a href="index.html">1</a> 2 <a
      href="notacion.html">3</a> <a href="espacial.html">4</a>
    </p>
  </footer>
</body>
</html>