package uo.ri.ui.cash.action;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import alb.util.console.Console;
import alb.util.date.DateUtil;
import alb.util.jdbc.Jdbc;
import alb.util.math.Round;
import alb.util.menu.Action;
import uo.ri.common.BusinessException;

public class FacturarReparacionesAction implements Action {

	private static final String precio_repuestos = "SELECT SUM(s.cantidad * r.precio)"
			+ " FROM TSustituciones s, TRepuestos r " + "WHERE s.repuesto_id = r.id "
			+ "AND s.intervencion_averia_id = ?";

	private static final String precio_obra = "SELECT SUM(i.minutos * tv.precioHora / 60) "
			+ "FROM TAverias a, TIntervenciones i, TVehiculos v, TTiposVehiculo tv " + "WHERE i.averia_id = a.id "
			+ "AND a.vehiculo_id = v.id " + "AND v.tipo_id = tv.id " + "AND a.id = ? " + "AND a.status = 'TERMINADA'";

	private static final String precio_averia = "UPDATE TAverias SET importe = ? WHERE id = ?";

	private static final String id_ultima_factura = "SELECT MAX(numero) FROM TFacturas";

	private static final String crear_factura = "INSERT INTO TFacturas(numero, fecha, iva, importe, status) VALUES(?, ?, ?, ?, ?)";

	private static final String link_averia_factura = "UPDATE TAverias SET factura_id = ? WHERE id = ?";

	private static final String actualizar_estado = "UPDATE TAverias SET status = ? WHERE id = ?";

	private static final String clave = "SELECT id FROM TFacturas WHERE numero = ?";

	private Connection connection;

	/**
	 * Proceso:
	 * 
	 * - Pide los ids de las averías a incluir en la factura. El usuario, antes,
	 * habrá listado las averias no facturadas del cliente y tendrá en pantalla,
	 * a la vista, los ids de las averías. - Verifica que las averías se pueden
	 * facturar (status 'TERMINADA') - Genera un nuevo número de factura (el
	 * último registrado + 1) - Calcula el importe de cada una de las averias y
	 * lo acumula al total de la factura - Calcula lo que corresponde por IVA
	 * (cuidado con la fecha) - Calcula el total (importe + IVA) y lo redondea a
	 * dos decimales (Round.twoCents( x )) - Establece como fecha de factura la
	 * del instante - Registra la factura en BDD - Vincula las averias con la
	 * factura generada - Pone el status de las averias a 'FACTURADA' -
	 * Finalmente, muestra el detalle de la factura generada en pantalla: nº de
	 * factura, fecha, importe, importe de IVA, importe total, status
	 * 
	 */

	@Override
	public void execute() throws BusinessException {

		List<Long> idsAveria = new ArrayList<Long>();

		// pedir las averias a incluir en la factura
		do {
			Long id = Console.readLong("ID de averia");
			idsAveria.add(id);
		} while (masAverias());

		try {
			connection = Jdbc.getConnection();
			connection.setAutoCommit(false);

			long numeroFactura = generarNuevoNumeroFactura();
			Date fechaFactura = DateUtil.today();
			double totalFactura = calcularImportesAverias(idsAveria);
			double iva = porcentajeIva(totalFactura, fechaFactura);
			double importe = totalFactura * (1 + iva / 100);
			importe = Round.twoCents(importe);

			long idFactura = crearFactura(numeroFactura, fechaFactura, iva, importe);
			vincularAveriasConFactura(idFactura, idsAveria);
			cambiarEstadoAverias(idsAveria, "FACTURADA");

			mostrarFactura(numeroFactura, fechaFactura, totalFactura, iva, importe);

			connection.commit();
		} catch (SQLException e) {
			try {
				connection.rollback();
			} catch (SQLException ex) {
			}
			;
			throw new RuntimeException(e);
		} catch (BusinessException e) {
			try {
				connection.rollback();
			} catch (SQLException ex) {
			}
			;
			throw e;
		} finally {
			Jdbc.close(connection);
		}

	}

	private void mostrarFactura(long numeroFactura, Date fechaFactura, double totalFactura, double iva,
			double totalConIva) {

		Console.printf("Factura nº: " + numeroFactura + "\n");
		Console.printf("\tFecha: " + fechaFactura.toString() + "\n");
		Console.printf("\tTotal:" + totalFactura + "€\n");
		Console.printf("\tIva: " + iva + " \n");
		Console.printf("\tTotal con IVA: " + totalConIva + " €\n");
	}

	private void cambiarEstadoAverias(List<Long> idsAveria, String status) throws SQLException {

		PreparedStatement pst = null;
		pst = connection.prepareStatement(actualizar_estado);

		for (Long idAveria : idsAveria) {
			pst.setString(1, status);
			pst.setLong(2, idAveria);

			pst.executeUpdate();
		}

		Jdbc.close(pst);

	}

	private void vincularAveriasConFactura(long idFactura, List<Long> idsAveria) throws SQLException {

		PreparedStatement pst = null;

		pst = connection.prepareStatement(link_averia_factura);

		for (Long idAveria : idsAveria) {
			pst.setLong(1, idFactura);
			pst.setLong(2, idAveria);

			pst.executeUpdate();
		}

		Jdbc.close(pst);

	}

	private long crearFactura(long numeroFactura, Date fechaFactura, double iva, double totalConIva)
			throws SQLException {

		PreparedStatement pst = null;

		pst = connection.prepareStatement(crear_factura);
		pst.setLong(1, numeroFactura);
		pst.setDate(2, new java.sql.Date(fechaFactura.getTime()));
		pst.setDouble(3, iva);
		pst.setDouble(4, totalConIva);
		pst.setString(5, "SIN_ABONAR");

		pst.executeUpdate();

		return getGeneratedKey(numeroFactura); // Id de la nueva factura
												// generada

		Jdbc.close(pst);

	}

	private long getGeneratedKey(long numeroFactura) throws SQLException {
		PreparedStatement pst = null;
		ResultSet rs = null;

		pst = connection.prepareStatement(clave);
		pst.setLong(1, numeroFactura);
		rs = pst.executeQuery();
		rs.next();
		Jdbc.close(rs, pst);
		return rs.getLong(1);

	}

	private Long generarNuevoNumeroFactura() throws SQLException {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = connection.prepareStatement(id_ultima_factura);
			rs = pst.executeQuery();

			if (rs.next()) {
				return rs.getLong(1) + 1; // +1, el siguiente
			} else { // todavía no hay ninguna
				return 1L;
			}
		} finally {
			Jdbc.close(rs, pst);
		}
	}

	private double porcentajeIva(double totalFactura, Date fechaFactura) {
		return DateUtil.fromString("1/7/2012").before(fechaFactura) ? 21.0 : 18.0;
	}

	protected double calcularImportesAverias(List<Long> idsAveria) throws BusinessException, SQLException {

		double totalFactura = 0.0;
		for (Long idAveria : idsAveria) {
			double importeManoObra = consultaImporteManoObra(idAveria);
			double importeRepuestos = consultaImporteRepuestos(idAveria);
			double totalAveria = importeManoObra + importeRepuestos;

			actualizarImporteAveria(idAveria, totalAveria);

			totalFactura += totalAveria;
		}
		return totalFactura;
	}

	private void actualizarImporteAveria(Long idAveria, double totalAveria) throws SQLException {
		PreparedStatement pst = null;

		pst = connection.prepareStatement(precio_averia);
		pst.setDouble(1, totalAveria);
		pst.setLong(2, idAveria);
		pst.executeUpdate();

		Jdbc.close(pst);

	}

	private double consultaImporteRepuestos(Long idAveria) throws SQLException {
		PreparedStatement pst = null;
		ResultSet rs = null;

		pst = connection.prepareStatement(precio_repuestos);
		pst.setLong(1, idAveria);

		rs = pst.executeQuery();
		if (rs.next() == false) {
			return 0.0; // La averia puede no tener repuestos
		}

		Jdbc.close(rs, pst);
		return rs.getDouble(1);

	}

	private double consultaImporteManoObra(Long idAveria) throws BusinessException, SQLException {
		PreparedStatement pst = null;
		ResultSet rs = null;

		pst = connection.prepareStatement(precio_obra);
		pst.setLong(1, idAveria);

		rs = pst.executeQuery();
		if (rs.next() == false) {
			throw new BusinessException("La averia no existe o no se puede facturar");
		}

		Jdbc.close(rs, pst);
		return rs.getDouble(1);

	}

	private boolean masAverias() {
		return Console.readString("¿Añadir más averias? (s/n) ").equalsIgnoreCase("s");
	}

}
